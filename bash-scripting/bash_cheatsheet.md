# ######################################MN   
# ### Великая Шпаргалка по Bash      ###
# ### Условия (if) и Циклы (for, while) ###
# ######################################


# ==========================================================
# Часть 1: Конструкция 'if' (Условия)
# ==========================================================
#
# Основная идея: 'if' проверяет КОД ВЫХОДА команды. 0 = успех/истина, не-0 = ошибка/ложь.

# --- Способы записи условия после 'if' ---

# 1. Проверка через 'test' (квадратные скобки)
#    Самый частый способ для переменных и файлов.

#    Одинарные скобки [ ... ] (классика)
#    - ОБЯЗАТЕЛЬНЫ пробелы после [ и перед ]
#    - ОБЯЗАТЕЛЬНО заключать переменные в "$VAR"
if [ "$USER" == "root" ]; then
  echo "You are root."
fi

#    Двойные скобки [[ ... ]] (современный стандарт)
#    - Умнее, безопаснее, позволяет использовать &&, ||
#    - РЕКОМЕНДУЕТСЯ использовать всегда, если пишешь для bash.
if [[ "$USER" == "root" || "$USER" == "admin" ]]; then
  echo "You are an administrator."
fi


# 2. Проверка кода выхода ЛЮБОЙ команды

#    Прямой вызов
#    Если 'grep' что-то найдет, его код выхода будет 0 (истина)
if grep -q "error" /var/log/syslog; then
  echo "Найдены ошибки в логе!"
fi

#    Проверка специальной переменной $?
#    '$?' всегда хранит код выхода ПОСЛЕДНЕЙ команды.
ping -c 1 ya.ru &> /dev/null
if [ $? -eq 0 ]; then
  echo "Пинг успешен."
else
  echo "Пинг не прошел."
fi


# 3. Арифметические вычисления (( ... ))
#    Удобный способ для математики, синтаксис как в других языках.

COUNT=10
if (( COUNT > 5 && COUNT < 20 )); then
  echo "Число в нужном диапазоне."
fi


# --- Полная структура 'if' ---

if [[ УСЛОВИЕ_1 ]]; then
  # Блок 1
elif [[ УСЛОВИЕ_2 ]]; then
  # Блок 2
else
  # Блок 3
fi


# ==========================================================
# Часть 2: Конструкция 'for' (Цикл с перебором)
# ==========================================================
#
# Основная идея: 'for' проходит по СПИСКУ элементов.

# --- Способы задания списка для 'for' ---

# 1. Явный список
for i in "apple" "banana" "cherry"; do echo $i; done

# 2. Генерация последовательности
#    Фигурные скобки (Brace Expansion)
for i in {1..5}; do echo $i; done
#    Команда 'seq'
for i in $(seq 1 2 10); do echo $i; done # от 1 до 10 с шагом 2

# 3. Перебор файлов (Globbing)
for f in /etc/*.conf; do echo "Found config: $f"; done

# 4. Перебор элементов массива
#    ВАЖНО: именно "${FILES[@]}" в кавычках для имен с пробелами
FILES=("file a.txt" "file b.txt")
for f in "${FILES[@]}"; do echo "Processing: $f"; done

# 5. Перебор вывода другой команды (Командная подстановка)
#    ВНИМАНИЕ: плохо работает с именами файлов, содержащими пробелы
for d in $(find /etc -maxdepth 1 -type d); do echo "Dir: $d"; done

# 6. "Си-подобный" цикл 'for' (для математики)
for (( i=0; i<5; i++ )); do echo "C-style: $i"; done


# ==========================================================
# Часть 3: Конструкция 'while' (Цикл с условием)
# ==========================================================
#
# Основная идея: 'while' выполняется, ПОКА команда-условие возвращает код 0 (истина).

# --- Способы задания условия для 'while' ---

# 1. Проверка через 'test' (квадратные скобки)
COUNTER=0
while [ $COUNTER -lt 3 ]; do
  echo "Counter: $COUNTER"
  ((COUNTER++))
done

# 2. Бесконечный цикл (выход через 'break' или 'exit')
# while true; do
#   echo "Looping..."
#   sleep 1
# done

# 3. Чтение файла/вывода команды построчно (САМЫЙ ВАЖНЫЙ ПАТТЕРН)
#    Ключ '-r' (raw) ОБЯЗАТЕЛЕН для корректного чтения.

#    Чтение файла
#    'done < "my_file.txt"' - перенаправление ввода для всего цикла
# while read -r LINE; do
#   echo "Строка из файла: ${LINE}"
# done < "my_file.txt"

#    Чтение вывода команды через пайп '|'
#    ВНИМАНИЕ: цикл выполняется в "подоболочке" (subshell)
# find . -type f | while read -r FILENAME; do
#   echo "Найден файл: ${FILENAME}"
# done


# ==========================================================
# Часть 4: Шпаргалка по операторам внутри [ ... ] и [[ ... ]]
# ==========================================================

# --- Файлы ---
# -e "/path"         Существует (файл ИЛИ директория)
# -f "/path/file"    Это обычный файл
# -d "/path/dir"     Это директория
# -s "file.txt"      Файл существует и не пустой
# -r "file.txt"      Есть право на чтение
# -w "file.txt"      Есть право на запись
# -x "script.sh"     Есть право на исполнение

# --- Строки ---
# "$A" == "$B"       Равны
# "$A" != "$B"       Не равны
# -z "$A"            Строка пустая (zero length)
# -n "$A"            Строка НЕ пустая (non-zero)
# "$str" =~ "$regex"   Совпадает с рег. выражением (только в [[ ... ]])

# --- Числа ---
# $N -eq 10          Равно (EQual)
# $N -ne 10          Не равно (Not Equal)
# $N -gt 10          Больше (Greater Than)
# $N -ge 10          Больше или равно (Greater or Equal)
# $N -lt 10          Меньше (Less Than)
# $N -le 10          Меньше или равно (Less or Equal)

# --- Логика ---
# !                  НЕ (инверсия) -> [ ! -f "file" ] (файл НЕ существует)
# &&                 И (AND) -> [[ $N -gt 5 && $N -lt 10 ]] (только в [[ ... ]])
# ||                 ИЛИ (OR) -> [[ "$U" == "root" || "$U" == "admin" ]] (только в [[ ... ]])
