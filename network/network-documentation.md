**Раздел "Схема сети L3"**

[ server2 ] <---> [ server1 ] <---> [ server3 ]
192.168.100.11    192.168.100.10    192.168.200.11
                  192.168.200.10

**Раздел маршрутизации**

/Server1/

# NAT, любой трафик, что мы не настроили, пойдет на шлюз 192.168.192.2 
default via 192.168.192.2 dev ens37 proto dhcp src 192.168.192.130 metric 101 
# Маршрут для первой локальной сети. Он говорит: 'Все, кто в подсети 192.168.100.0/24,
# подключены ко мне через интерфейс ens33. Шлюз не нужен, я могу докричаться до них сам'
192.168.100.0/24 dev ens33 proto kernel scope link src 192.168.100.10 metric 100
# Аналогично для подсети интерфейса ens37 
192.168.192.0/24 dev ens37 proto kernel scope link src 192.168.192.130 metric 101 
# Аналогично для подсети интерфейса ens38 
192.168.200.0/24 dev ens38 proto kernel scope link src 192.168.200.10 metric 102 

/Server2/

# Виртуальная сеть для докера
172.17.0.0/16 dev docker0 proto kernel scope link src 172. 17.0.1 linkdown
# Собственная локальная сеть, можно достучаться до всех кто находится в 192.168.100.0/24
192.168.100.0/24 dev ens33 proto kernel scope link src 192.168.100.11
# Статика: 'Чтобы добраться до любого адреса в 'чужой' сети 192.168.200.0/24,
# отправляй пакеты на шлюз 192.168.100.10 (server1) через мой интерфейс ens33'.
# Без этого правила server2 не знал бы, что делать с пакетами для server3".
192.168.200.0/24 via 192.168.100.10 dev ens33 proto static

/Server3/

# Статика в сеть 192.168.100.0/24 (server2) через server1
192.168.100.0/24 via 192.168.200.10 dev ens37 proto static
# Родная локалка
192.168.200.0/24 dev ens37 proto kernel scope link src 192.168.200.11

**Раздел DNS**

127.0.0.1 localhost
127.0.1.1 vlad-VMware-Virtual-Platform
192.168.100.10 server1.lab.local server1 web.lab.local
192.168.100.11 server2.lab.local server2

Добавив в /etc/hosts наши адреса мы можем уточнить их "названия" в буквенном виде,
соответственно, теперь мы удобно можем пропинговать наш server1 в том числе и через
web.lab.local


**Раздел Трассировки пути пакета**

[Задача: Описать путь команды ping 192.168.200.11 с server2.]

Шаг 1: На server2 (Отправка)
Ядро server2 получает команду. Оно смотрит на IP-адрес назначения: 192.168.200.11.
Оно открывает свою таблицу маршрутизации и ищет самое точное правило.
Правило для 192.168.100.0/24 не подходит.
О! Есть правило 192.168.200.0/24 via 192.168.100.10. Адрес назначения подходит под это правило.
Вывод: "Пакет нужно отправить на шлюз 192.168.100.10".
Теперь ядру нужно отправить пакет на 192.168.100.10. Это L3-задача.
Чтобы сделать это на L2 (физически), ему нужен MAC-адрес этого шлюза.
Ядро смотрит в свою ARP-таблицу (ip neigh).
Если запись для 192.168.100.10 есть — отлично, берем MAC-адрес оттуда.
Если нет — запускается ARP-запрос: server2 кричит в сеть 192.168.100.0/24:
"Кто тут 192.168.100.10, скажите свой MAC!". server1 отвечает. Запись добавляется в кэш.
server2 формирует Ethernet-кадр и отправляет его:
Source MAC: MAC-адрес server2.
Destination MAC: MAC-адрес server1!
Source IP: 192.168.100.11
Destination IP: 192.168.200.11!

Шаг 2: На server1 (Маршрутизация)
server1 получает пакет на свой интерфейс ens33.
Он видит, что MAC-адрес назначения — его, но IP-адрес назначения — не его.
Он проверяет, включен ли у него IP-форвардинг (net.ipv4.ip_forward=1). Да, включен!
Вывод: "Этот пакет не для меня, его нужно переслать".
Куда переслать? server1 смотрит в свою таблицу маршрутизации,чтобы найти путь для 192.168.200.11.
Он находит правило 192.168.200.0/24 dev ens38.... "Ага!
Эта сеть подключена ко мне напрямую через интерфейс ens38".
Теперь server1 должен отправить пакет на конечный IP 192.168.200.11
через ens38. Ему нужен MAC-адрес server3.
Он смотрит в свою ARP-таблицу. Если записи нет, он отправляет ARP-запрос
уже в сеть 192.168.200.0/24: "Кто тут 192.168.200.11, скажите свой MAC!". server3 отвечает.
server1 "раздевает" старый Ethernet-кадр и "одевает" пакет в новый:
Source MAC: MAC-адрес интерфейса ens38 на server1.
Destination MAC: MAC-адрес server3.
Source IP: 192.168.100.11 (все еще оригинальный!)
Destination IP: 192.168.200.11 (все еще оригинальный!)
Пакет уходит с интерфейса ens38.
Шаг 3: На server3 (Прием) и обратный путь
server3 получает пакет. IP-адрес назначения его, он обрабатывает ICMP-запрос
и формирует ответ — ICMP echo reply.
Теперь этот ответный пакет должен пройти весь путь обратно.
Source IP: 192.168.200.11
Destination IP: 192.168.100.11
server3 смотрит в свою таблицу маршрутизации и находит правило
192.168.100.0/24 via 192.168.200.10. Он отправляет ответный пакет на server1.
server1 получает его, снова пересылает между интерфейсами и отправляет на server2.
server2 получает echo reply. Пинг успешен.
